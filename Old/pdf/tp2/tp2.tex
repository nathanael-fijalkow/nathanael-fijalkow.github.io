\documentclass[10pt]{tpcaml}
\tp{2}{Sudoku}

% TP CaML HIV 2010
% par Nathanaël FIJALKOW
% Utilise les classes LaTeX de Victor Nicollet

\begin{document}
  \maketitle

L'objectif de ce TP est de résoudre un sudoku de manière automatique,
et disons-le tout de suite, peu subtile, par la méthode du backtracking
(d'aucuns diraient ''retour sur trace``).
Pour cela, une fois n'est pas coutume, nous utiliserons un peu de programmation impérative,
par opposition à récursive.

La première section est une mise au point sur un écueil courant : les fonctions
à plusieurs paramètres et le placement des parenthèses.
La deuxième section est une mise au point sur la programmation impérative.

\section{Traitement des fonctions à plusieurs paramètres}

\begin{codesection}
  \# let deux\_fois f = (fun x -> f x + f x);;\\
  \# deux\_fois (fun n -> n + 1) 3 ;;\\
  - : int = 8
\end{codesection}

Une fonction est une valeur comme les autres. Elle peut par exemple
être passée en argument d'une autre fonction, ou renvoyée comme valeur
de retour. Ici, \code{deux\_fois} prend une fonction \code{f} en
paramètre et renvoie une autre fonction (\code{fun x -> ..}).

Si l'on fait un peu attention, on peut aussi voir \code{deux\_fois}
comme une fonction qui prend deux arguments, $f$ et $x$, et renvoie
$f(x) + f(x)$. On peut d'ailleurs écrire (et c'est strictement
équivalent) :\\ \code{let deux\_fois f x = f x + f x}.

Cette méthode permet d'exprimer des fonctions à plusieurs
arguments. On peut la généraliser à un nombre quelconque (mais fixé
à l'avance) d'arguments. Elle s'appelle la \emph{curryfication}, et
correspond à l'isomorphisme, en mathématiques, entre $(A \times B) \to
C$ et $A \to (B \to C)$.

\paragraph{Remarque :} Avec les fonctions à plusieurs arguments, on
voit apparaître des types de la forme\\ \code{int -> int -> int}. Dans
ces cas là il faut lire (la flèche est associative à droite)
\code{int -> (int -> int)}.

\paragraph{Notations}

On peut écrire \code{let f x = a} à la place de
\code{let f = fun x -> a}. Selon le même principe, on peut simplifier
l'écriture de fonctions à plusieurs paramètres :
\begin{itemize}
\item on peut compresser une suite de \code{fun} : le code \code{fun
    x -> fun y -> z} s'écrit aussi \code{fun x y -> z}.
\item on peut faire rentrer plusieurs \code{fun} dans un \code{let} :
  \code{let f = fun x y -> z} s'écrit aussi \code{let f x y = z}.
\end{itemize}

Il faut bien comprendre que ces notations représentent exactement le
même code.

\subsection{Application partielle}

\begin{codesection}
\# let somme x y = x + y;;\\
\# let somme' x = fun y -> x + y;;\\
\# let somme\_3 = somme' 3;;\\
\# somme\_3 2;;\\
- int : 5
\end{codesection}

Il n'y a pas à proprement parler de ``fonction à deux arguments'' en Caml.
Il y a par contre des fonctions qui prennent un argument,
puis renvoient une fonction qui prend un deuxième argument et
renvoie un résultat. En particulier, fournir un seul argument 
à une fonction Caml est toujours défini, vous n'aurez
jamais d'erreur du style ``Vous n'avez pas fourni assez d'arguments''.

Par exemple, dans le code ci-contre, les fonctions \code{somme} et
\code{somme'} sont exactement identiques, mais la deuxième permet
mieux de comprendre ce que signifie \code{somme 3} : c'est la fonction
qui, quand on lui donne un paramètre, lui ajoute 3. On parle dans ce
cadre d'\emph{application partielle} : on a donné seulement une partie
des arguments à la fonction.

\subsection{Placement des parenthèses}

La source d'erreur est le fait que le placement des parenthèses en Caml
est \emph{différent} de la notation mathématique habituelle.

Les parenthèses utilisées autour des expressions n'ont \emph{pas de
 signification}. Elles servent uniquement à éliminer les ambiguités,
comme en mathématiques (différence entre $1 + 2 * 3$ et $(1 + 2) *
3$).

Pour appeler une fonction \code{f} avec un argument \code{x}, on écrit
simplement \code{f x}. Vous pouvez aussi écrire \code{(f x)},
\code{(f)x}, \code{f(x)} ou \code{(f)((x))} si cela vous fait plaisir,
mais contrairement à la notation mathématique, les parenthèses autour
du \code{x} ne sont \emph{pas} nécessaires, et je vous déconseille de
les mettre.

Le problème de la notation mathématique est son extension aux appels
de fonction à plusieurs arguments, comme par exemple \code{g x y} : on
donne à la fonction \code{g} l'argument \code{x}, puis \code{y}. Si
l'on veut être précis, on dit que l'application de \code{x} à \code{g}
renvoie une fonction (\code{g} est de la forme \code{fun a -> fun b ->
  c}), et que c'est à cette fonction qu'on applique y. On pourrait
donc aussi écrire \code{let h = g x in h y} ou \code{(g x) y}.

C'est ici que la notation mathématique à laquelle vous êtes habitués
risque de vous faire faire des erreurs. \code{g x y} est équivalent
à \code{(g x) y}, mais \textbf{pas} à \code{g(x y)} ! Cette deuxième
écriture signifie qu'on applique \code{y} à \code{x}, et qu'on donne
le résultat à \code{g}. Par contre, si vous voulez écrire $f(g(x))$,
c'est bien \code{f (g x)} et pas \code{f g x} !

\begin{codesection}
let f x y = () ;;\\
let a = ref 0 in f (a := 1) (a := 2) ; !a ;;
\end{codesection}
\begin{question}
Que déduire du code ci-contre?
\end{question}

\section{Rappels de programmation impérative}

\subsection{Champs modifiables}

En \caml, les variables ne sont pas \emph{modifiables} : une fois
qu'une variable a été déclarée par un \code{let}, sa valeur ne change
pas (jusqu'à la déclaration suivante).

Si \code{'a} est un type \caml, \code{'a ref} désigne le type des \emph{références}
contenant une valeur de type \code{'a}.
On peut voir une référence \code{x} comme un tiroir : on
peut l'ouvrir pour regarder à l'intérieur (avec \code{!x}, on voit
un objet de type \code{'a}), ou bien changer son contenu pour y mettre
la valeur \code{v} de type \code{'a}, (avec \code{x := v}).

\begin{codesection}
let test =\\
\ \ let a, b = ref 1, ref 2 in\\
\ \ let c, d = a, ref a in\\
\ \ a := !a + !b; d := c; !(!d) + !a;;
\end{codesection}

Pour créer une nouvelle référence, on utilise la fonction \code{ref}
en lui donnant une valeur de départ (la valeur que contiendra le
tiroir avant que son contenu ne soit modifié). Attention à la
subtilité : quand on utilise l'opérateur \code{:=}, on change le
\emph{contenu} de la référence, pas la référence elle-même (qui
désigne toujours le même tiroir) !

\begin{question}
  Quelle est la valeur de la variable \code{test} ?
\end{question}

Les cases des tableaux et des chaînes de caractères sont aussi des
champs modifiables : \code{tab.(i)} et \code{str.[i]} permettent
d'obtenir la valeur en i-ème position (en partant de 0) du tableau
\code{tab} et de la chaîne \code{str}. Pour les modifier on n'utilise
pas ``\code{:=}'' mais ``\code{<-}'' : par exemple \code{tab.(i) <- v}.

% Les enregistrements (types produits utilisant la syntaxe
% \code{\{ ... \}}) peuvent avoir certains champs modifiables, si c'est
% précisé à la déclaration par le mot-clé \code{mutable} :\\
% \code{type 'a reference = \{mutable contents : 'a\};;}
% 
% On peut alors modifier le champ avec la syntaxe \code{x.champ <- v}.

\subsection{Exceptions}

Les exceptions sont une manière d'interrompre une partie d'un
programme en cas d'erreur. Par exemple, si vous avez une
formule mathématique à calculer, et qu'en plein calcul vous vous
apercevez que vous devez diviser 0, vous allez vous arrêter et vous
plaindre que la formule n'est pas bien définie. \caml\ sait faire
pareil.

\begin{codesection}
  \#exception Erreur of string;;\\
let boum () = raise (Erreur "boum");;\\
\\
try (boum (); "message") with\\
\  | Exit -> "sortie"\\
\  | Erreur message -> "erreur : " \^\ message\\
\  | \_ -> "exception inconnue"
\end{codesection}

Les expressions sont des objets de type \code{exn} qui ressemblent
beaucoup aux types sommes définis dans le précédent TP : ce sont des
constructeurs, qui peuvent comporter des arguments, et sont déclarés
par le mot-clé \code{exception}.

Quand on a trouvé une erreur, on peut \emph{lancer} une expression
avec la fonction \code{raise} : elle prend une expression en
paramètre, et interromp le calcul (en particulier, tout ce qui devait
se passer ensuite dans le programme n'est pas exécuté).

Cela permet de faire des erreurs qui stoppent complètement le
calcul. Parfois, on voudrait plutôt détecter l'erreur et utiliser une
solution adaptée pour continuer le programme (par exemple si l'erreur
est ``plus de papier dans l'imprimante'', il suffit de demander
à l'utilisateur de rajouter du papier avant de continuer, au lieu
d'annuler complètement l'impression en cours). On peut
\emph{rattrapper} une exception avec la construction 
\code{try <expr> with <filtrage>}.
Cela se présente un peu comme un
\code{match ... with}, mais le comportement est différent :
\begin{itemize}
  \item si l'évaluation de \code{<expr>} ne provoque aucune exception, on renvoie sa valeur
  \item sinon, on effectue le filtrage sur la valeur de l'exception envoyée
\end{itemize}

\begin{question}
\'Ecrire une fonction \code{existe} avec une boucle \code{for},
tel que \code{existe elt tableau} teste l'existence de \code{elt} dans le tableau \code{tableau}
en parcourant le moins possible d'éléments du tableau.
\end{question}

\begin{question}
Quel est le type de \code{raise} ? Pourquoi ?
\end{question}

\subsection{Dangers}

\begin{codesection}
let nouvelle\_matrice n p x =\\
\ \ Array.make n (Array.make p x);;\\
let mat = nouvelle\_matrice 3 3 0;;\\
 mat.(0).(1) <- 2; mat;;
\end{codesection}

On veut créer un tableau à deux dimensions, sans utiliser la fonction déjà toute faite \code{Array.make\_matrix}.

\begin{question}
  Quel est le problème avec \code{mat} ?\\
  Coder (correctement) \code{nouvelle\_matrice} avec une boucle.
\end{question}

\section{Sudoku}

Les sudokus classiques sont des grilles $9 \times 9$ où chaque case est soit blanche, soit contient un chiffre parmi $\set{1,\ldots,9}$. Par convention, les cases blanches contiennent des $0$.
L'objectif est de remplir les cases blanches, de manière à ce que sur chaque ligne, sur chaque colonne, et sur chacun des $9$ carrés $3 \times 3$,
chaque chiffre apparaît une fois et une seule. Ce sont des sudokus d'ordre $3$. 

Un sudoku d'ordre $n$ est une grille $n^2 \times n^2$ où chaque case est soit blanche,
soit contient un nombre parmi $\set{1,\ldots,n^2}$.
L'objectif est de remplir les cases blanches, de manière à ce que sur chaque ligne, sur chaque colonne, et sur chacun des $n^2$ carrés $n \times n$,
chaque chiffre apparaît une fois et une seule.

\begin{codesection}
let resoudre\_sudoku n grille =\\
let nc = n * n in\\
let rec boucle liste\_choix =\\
try\\
\  if correct n nc grille liste\_choix\\
\ \    then boucle (choix\_suivant nc grille liste\_choix)\\
\ \    else boucle (changer\_choix nc grille liste\_choix)\\
with\\ 
\ \ | Fini -> retourner\_solution nc grille liste\_choix\\
\ \ | Echec -> failwith "pas de solution"\\
in boucle [] ;;
\end{codesection}

Pour résoudre un sudoku, nous allons utiliser la méthode du backtracking. 
L'entrée est un entier $n$ et une grille $n^2 \times n^2$. \textbf{Cette grille ne sera pas modifiée}.
On procède récursivement, en maintenant une liste des choix effectués, sous la forme de triplet $(i,j,k)$ : ligne $i$, colonne $j$, on place l'entier $k$.
L'algorithme procède ainsi : si les conditions du sudoku ne sont pas violées, alors faire un nouveau choix, sinon revenir en arrière, c'est-à-dire modifier le dernier choix qui peut l'être et supprimer les choix faits après celui-ci. S'il n'est pas possible de revenir en arrière, c'est qu'il n'y a pas de solution.

%Recopiez la fonction \code{resoudre\_sudoku}. 
%Il vous reste quatre fonctions principales à coder : \code{correct}, \code{choix\_suivant}, \code{changer\_choix} et \code{retourner\_solution}.

\begin{question}
Coder la fonction \code{choix\_suivant}.
Elle déclenche l'exception \code{Fini} s'il n'y a plus de case libre. 
\end{question}

\begin{question}
Coder la fonction \code{changer\_choix}.
Elle déclenche l'exception \code{Echec} s'il n'est pas possible de revenir en arrière.
\end{question}

\begin{question}
Coder la fonction \code{correct}. Remarquer qu'il est inutile de tester toute la grille, seulement une ligne, une colonne et un carré.
Coder la fonction \code{retourner\_solution}. 
Tester votre code, par exemple sur une grille vide.
\end{question}

\begin{question}
Modifier à peine le code pour rendre toutes les solutions (au lieu de rendre la première trouvée).
\end{question}

\begin{question}
Fixons une grille d'ordre $n$ possédant $k$ cases blanches. Une configuration est une liste de triplets, remplissant certaines des cases blanches de la grille. Elle est valide si elle ne viole pas les conditions du sudoku une fois insérée dans la grille.
L'ensemble des configurations valides peut être représenté de manière à interpréter l'algorithme implémenté : plaçons tout en haut la configuration vide (liste vide). \'Etant donné une configuration valide $c$, on lui associe des fils, qui sont les configurations valides qui étendent la configuration $c$ d'exactement un triplet.
Ceci définit (il faudrait être plus précis) l'arbre des configurations. Que représentent les feuilles ? Quelle est la taille de cet arbre, combien y a t-il de feuilles (en fonction de $n$ et $k$) ?
Dernière question : l'algorithme implémenté parcourt les configurations. Décrire le parcours de l'arbre qu'il effectue. Votre modification du code (question précédente) visite t-il toutes les configurations ?
\end{question}

\begin{question}
La fonction \code{resoudre\_sudoku} est-elle récursive terminale?
\end{question}

\begin{question}
De nombreuses optimisations sont possibles, dont certaines s'appuie sur une étude fine de l'arbre des configurations.
Proposer et implémenter quelques optimisations.
\end{question}

\section{Question difficile}

Cette dernière partie est une petite incursion vers ce que cache la programmation fonctionnelle (à savoir le lambda-calcul).
L'entier de Church noté $\hat{n}$ est la fonction qui à $f$ associe $f^n$ (l'itérée $n$ fois de $f$).

\begin{codesection}
let rec church n f x =\\
\  if n = 0 then x\\
\ else church (n-1) f (f x);;
\end{codesection}

On peut le définir en \caml\ par :

Ainsi \code{church n} retourne $\hat{n}$.

\begin{question}
Quel est le type de $\hat{n}$?
\end{question}

\begin{question}
Coder $\hat{0}, \hat{1}$ et $\hat{2}$.
\end{question}

\begin{question}
Coder la fonction $\code{eval}$ qui à $\hat{n}$ associe $n$.
\end{question}

\begin{question}
Coder la fonction $\code{succ}$ qui à $\hat{n}$ associe $\hat{n+1}$.
\end{question}

\begin{question}
Coder les fonctions $\code{add}, \code{mult}$ et $\code{exp}$ qui calculent la somme, le produit et l'exponentiation 
de deux entiers de Church.
\end{question}

\end{document}
