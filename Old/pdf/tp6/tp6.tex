\documentclass{tpcaml}
\tp{6}{Automates}

% TP CaML LLG 2011 / 2012
% par Nathanaël FIJALKOW
% Utilise les classes LaTeX de Victor Nicollet

\begin{document}
  \maketitle

Pour ce premier TP de l'année, nous allons implémenter des automates.
L'objectif de ce TP est d'écrire les fonctions utiles que nous utiliserons plus tard pour manipuler nos automates.

\section{Mots et langages}

L'alphabet latin (ISO/IEC 8859-1) contient 256 caractères, et est le plus largement utilisé pour
des raisons historiques, malgré l'émergence d'un nouvel alphabet plus complet (UTF-8, qui contient
95 000 caractères). En Caml light, l'alphabet en 256 caractères (le plus souvent ISO/IEC 8859-1)
est manipulé par le type \code{char} (un caractère) et le type \code{string} (un mot). 

\'Etant donné un mot $u$ (donc un élément de type \code{string}), on accède à sa $i$-ème lettre par $u.[i]$,
et comme pour les vecteurs les positions sont indexées à partir de $0$.
La longueur du mot $u$ est donnée par \code{string\_length u}.

\section{Automates déterministes}

Les automates que l'on considère dans cette partie sont déterministes (pour chaque couple (état,lettre), 
il y a \textit{au plus} une transition). 

\begin{codesection}
type automate = \\
\quad \{ taille : int ;\\
\quad	 \quad initial : int ;\\
\quad    \quad transitions : (char * int) list vect ;\\
\quad	 \quad final : bool vect \} ;;
\end{codesection}

\noindent L'enregistrement \code{taille} donne le nombre d'états.
L'état initial est donné par l'enregistrement \code{initial}, 
et les états finaux sont donnés par le vecteur de booléens \code{final}.
Le tableau \code{transitions} contient l'ensemble des transitions.

La taille des tableaux \code{transitions} et \code{final} doit \^etre \code{taille}, mais ceci n'est pas spécifié dans le type.

\begin{question}
\'Ecrire une fonction \code{calcul\_det} qui étant donné un mot et un automate supposé déterministe, 
détermine si l'automate accepte ce mot.
Quelle est sa complexité ?
\end{question}

\begin{figure}[h]
\begin{center}
\begin{picture}(40,40)(0,0)
	\gasset{Nw=8,Nh=8}

  	\node[Nmarks=i](0)(0,20){$0$}
  	\node[fangle=90,Nmarks=f](1)(20,30){$1$}
  	\node(2)(20,10){$2$}
  	\node[fangle=0,Nmarks=f](3)(40,20){$3$}
  	\node(4)(40,0){$4$}

  	\drawedge(0,1){$a$}
  	\drawedge(0,2){$b$}
	\drawloop[loopangle=0](1){$a$}
  	\drawedge(2,3){$a$}
  	\drawedge(2,4){$b$}
  	\drawedge[curvedepth=3](3,4){$b$}
  	\drawedge[curvedepth=3](4,3){$a$}
\end{picture}
\end{center}
\end{figure}

\begin{question}
Définir l'automate ci-dessus, et vérifier sur les exemples $aa$, $aba$ et $bab$ que la fonction \code{calcul\_det} est correcte.
\end{question}

\begin{question}
\'Ecrire une fonction \code{accessible} qui supprime les états inaccessibles d'un automate.
Pour cela, on doit renuméroter les états, on pourra maintenir deux tableaux \code{tab\_conv} et \code{tab\_inv} 
qui gère la correspondance entre nouveaux et anciens états.
\end{question}

\section{Automates non-déterministes}

Considérons à présent les automates non-déterministes, toujours avec le type \code{automate}.

\begin{question}
\'Ecrire une fonction \code{calcul\_nondet} qui étant donné un mot et un automate,
détermine si l'automate accepte le mot.
Quelle est sa complexité ?
\end{question}

\begin{figure}
\begin{center}
\begin{picture}(40,40)(0,0)
	\gasset{Nw=8,Nh=8}

  	\node[Nmarks=i](0)(0,20){$0$}
  	\node[fangle=90,Nmarks=f](1)(20,30){$1$}
  	\node(2)(20,10){$2$}
  	\node[fangle=0,Nmarks=f](3)(40,20){$3$}
  	\node(4)(40,0){$4$}

  	\drawedge(0,1){$a$}
  	\drawedge(0,2){$a,b$}
	\drawloop[loopangle=0](1){$a$}
  	\drawedge(2,3){$a$}
  	\drawedge(2,4){$b$}
  	\drawedge[curvedepth=3](3,4){$b$}
  	\drawedge[curvedepth=3](4,3){$a$}
\end{picture}
\end{center}
\end{figure}

\begin{question}
Définir l'automate représenté ci-dessus, et vérifier sur les exemples $aa$, $aba$ et $bab$ que la fonction \code{calcul\_nondet} 
est correcte.
\end{question}

\section{Déterminisation}

Pour déterminiser un automate, on construit l'automate des parties : étant donné un automate non-déterministe 
$\A = (Q = \set{0,\ldots,n-1},0,\delta,F)$, son déterminisé est $\widehat{\A} = (2^Q,\set{0},\delta',F')$, où
$$\delta'(S,a) = \set{q' \in Q \mid \exists q \in S, (q,a,q') \in \delta}$$
et $$F' = \set{S \subseteq Q \mid S \cap F \neq \emptyset}\ .$$

Pour représenter les états de $\widehat{\A}$, on code les sous-ensembles $S \subseteq \set{0,\ldots,n-1}$ 
par des entiers.
Par exemple, $\set{0,2,3}$ est représenté par le tableau de booléens \code{[| true ; false ; true ; true |]},
et de manière équivalente par l'entier $2^0 + 2^2 + 2^3 = 13$.

\begin{question}
\'Ecrire les fonctions de conversion \code{tab2int} et \code{int2tab}.
La fonction \code{int2tab} prend en argument l'entier $k$ à convertir et la taille $n$ du tableau attendu.
\end{question}

\begin{question}
\'Ecrire une fonction \code{determinise} qui calcule l'automate déterminisé.
\end{question}

Le nombre d'états de $\widehat{\A}$ est exponentiel en le nombre d'états de $\A$; ceci rend impraticable la déterminisation
dès que $\A$ est gros. 
En pratique, on préfère calculer seulement la partie accessible de $\widehat{\A}$.
En effet, \textit{souvent}, le déterminisé a (beaucoup) moins que $2^n$ états.
Cependant, dans certains cas cette borne est atteinte :

\begin{question}
Construire un automate non-déterministe reconnaisant $L_n = A^* \cdot a \cdot A^{n-1}$.
Montrer que tout automate déterministe reconnaissant $L_n$ possède au moins $2^n$ états.
\end{question}

\section{Minimisation}

Pour minimiser un automate (déterministe et complet), on calcule l'équivalence de Nérode.
\'Etant donné $\A = (Q = \set{0,\ldots,n-1},0,\delta,F)$, c'est la relation d'équivalence sur $Q$
définie par 
$$p \sim q \Longleftrightarrow \forall w \in A^*,\ (p \cdot w \in L(\A) \Leftrightarrow q \cdot w \in L(\A))\ .$$

On la calcule par approximations successives : on définit les relations $\sim_k$ pour $k \in \N$ par 
$$p \sim_k q \Longleftrightarrow \forall w \in A^{\leq k},\ (p \cdot w \in L(\A) \Leftrightarrow q \cdot w \in L(\A))\ .$$
$A^{\leq k}$ est l'ensemble des mots de longueur au plus $k$.

\begin{question}
Montrer que $\sim\ =\ \sim_{n-2}$.
\end{question}


Pour maintenir ces relations successives, on utilise un tableau \code{tab\_partition} d'entiers de taille $n$.
La valeur \code{tab\_partition.(i)} est un état $j \leq i$ qui est en relation avec $i$.
La fonction \code{classe} calcule le représentant minimal de la classe de $i$, et met à jour les valeurs
des états considérés.
Pour tester si deux états sont en relation, il suffit de calculer les représentants minimaux de leurs deux classes,
et de les comparer.


\begin{question}
\'Ecrire une fonction \code{minimise} qui calcule l'automate minimal.
Tester sur l'automate ci-dessus.
\end{question}

\begin{figure}
\begin{center}
\begin{picture}(40,40)(0,0)
	\gasset{Nw=8,Nh=8}

  	\node[Nmarks=i](0)(0,20){$0$}
  	\node[fangle=45,Nmarks=f](1)(20,30){$1$}
  	\node[fangle=-45,Nmarks=f](2)(20,10){$2$}
  	\node(3)(40,20){$3$}

  	\drawedge(0,1){$a$}
  	\drawedge(0,2){$b$}
	\drawloop[loopangle=135](1){$a$}
  	\drawedge(1,3){$b$}
  	\drawedge(2,3){$b$}
	\drawloop[loopangle=-135](2){$a$}
	\drawloop[loopangle=0](3){$a,b$}
\end{picture}
\end{center}
\end{figure}

%\begin{codesection}
%let rec classe tab i =\\
%  if tab.(i) = i \\
%  then i \\
%  else let j = classe tab tab.(i) in tab.(i) <- j ; j;;\\
%\\
%let equ tab i j =\\
%  classe tab i = classe tab j ;;\\
%\end{codesection}

\end{document}
