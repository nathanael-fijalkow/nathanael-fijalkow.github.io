\documentclass{tpcaml}
\tp{7}{Union-Find et minimisation d'automates}

% TP CaML LLG 2011 / 2012
% par Nathanaël FIJALKOW
% Utilise les classes LaTeX de Victor Nicollet

\begin{document}
  \maketitle

Ce deuxième TP de l'année fait suite au premier : notre objectif est maintenant de minimiser des automates déterministes.
Pour cela, il faut savoir gérer des partitions, nous commençons donc par étudier l'algorithme Union-Find,
avant de l'appliquer à la minimisation.

\section{Algorithme Union-Find}

On considère $n$ objets (que nous appellerons $0,1,\ldots,n-1$) 
sur lesquels on définit des partitions.
L'objectif est de construire une structure permettant d'effectuer les opérations suivantes :
\begin{itemize}
	\item initialiser à la partition la plus fine où chaque classe est un singleton ;
	\item déterminer si deux éléments sont dans la m\^eme classe;
	\item modifier la relation pour fusionner les classes de deux éléments ;
	\item compter le nombre de classes de la partition ;
\end{itemize}

\subsection{Une solution na\"ive}

Donner une implémentation en mettant simplement à jour un vecteur $v$ 
tel que $\code{v.(x)}$ contient l'élément minimal de la classe d'équivalence de $x$.

\begin{question} 
\'Ecrire les fonctions suivantes :

\begin{tabular}{l}
\code{initialise : int -> int vect}  \\
\code{compte : int vect -> int} \\
\code{test\_equ : int vect -> int -> int -> bool} \\
\code{fusion : int vect -> int -> int -> unit}.
\end{tabular}

Quelle est la complexité de chacune de ces opérations ?
\end{question}

\subsection{Utiliser des arbres et des forêts}

On peut représenter une partition par une forêt d'arbres. 
Par exemple la partition $\set{0, 1, 5}, \set{2, 3}, \set{4}$ pourra être représentée 
par l'une des forêts ci-dessous :

\begin{figure}[!h]
\begin{center}
\begin{picture}(100,45)(0,-5)
	\gasset{Nw=8,Nh=8}

  	\node(1g)(10,30){$1$}
  	\node(0g)(0,15){$0$}
  	\node(5g)(20,15){$5$}
  	\node(3g)(32.5,30){$3$}
  	\node(2g)(32.5,15){$2$}
  	\node(4g)(45,30){$4$}

  	\drawedge(0g,1g){}
  	\drawedge(5g,1g){}
  	\drawedge(2g,3g){}

	\drawline[AHnb=0](55,-8)(55,37)

  	\node(0d)(65,30){$0$}
  	\node(1d)(65,15){$1$}
  	\node(5d)(65,0){$5$}
  	\node(2d)(77.5,30){$2$}
  	\node(3d)(77.5,15){$3$}
  	\node(4d)(90,30){$4$}

  	\drawedge(1d,0d){}
  	\drawedge(5d,1d){}
  	\drawedge(3d,2d){}
\end{picture}
\end{center}
\end{figure}

On représentera ce genre de forêt par un couple \code{(taille,pere)}, où \code{taille}
est le nombre de parties de la partition, c'est-à-dire le nombre d'arbres
de la forêt, et \code{pere.(x)} vaut \code{x} si \code{x} est la racine de son arbre,
et la valeur de son père dans son arbre sinon.

Ainsi la structure utilisée est du type :\\
\code{type structure = \{ mutable taille : int ; pere : int vect \} ;;}

\begin{question} 
\'Ecrire pour cette nouvelle structure les fonctions suivantes :

\begin{tabular}{l}
\code{initialise : int -> int vect}  \\
\code{compte : int vect -> int} \\
\code{test\_equ : int vect -> int -> int -> bool} \\
\code{fusion : int vect -> int -> int -> unit}.
\end{tabular}

Quelle est la complexité de chacune de ces opérations ?
\end{question}

\subsection{Optimisation}

Une première optimisation consiste à limiter la profondeur des arbres lorsque l'on effectue une fusion:
pour cela, on maintient à jour un nouveau vecteur \code{poids}, 
tel que \code{poids.(x)} contienne la taille du sous-arbre enraciné en \code{x}.

La structure devient :\\
\code{type structure = \{ mutable taille : int ; pere : int vect ; poids : int vect \} ;;}

\begin{question} 
Modifier les fonctions pour utiliser la nouvelle structure.
\end{question}

La seconde optimisation est la compression des chemins :
à chaque fois qu'on calcule un représentant minimal pour une partie, on ``remonte'' les éléments considérés
dans l'arbre, en les placant directement en dessous de la racine.

\begin{question} 
Modifier les fonctions en faisant de la compression des chemins.
Que se passe t-il pour le tableau \code{poids} ?
\end{question}

\section{Minimisation d'automates déterministes}

Les automates que l'on considère dans ce TP sont déterministes (pour chaque couple (état,lettre), 
il y a \textit{au plus} une transition) et complet (pour chaque couple (état,lettre), 
il y a \textit{au moins} une transition).

\begin{codesection}
type automate = \\
\quad \{ taille : int ;\\
\quad	 \quad initial : int ;\\
\quad    \quad transitions : (char * int) list vect ;\\
\quad	 \quad final : bool vect \} ;;
\end{codesection}

Pour minimiser un automate (déterministe et complet), on calcule l'équivalence de Nérode.
\'Etant donné $\A = (Q = \set{0,\ldots,n-1},q_0,\delta,F)$, c'est la relation d'équivalence sur $Q$
définie par 
$$p \sim q \Longleftrightarrow \forall w \in A^*,\ (p \cdot w \in L(\A) \Leftrightarrow q \cdot w \in L(\A))\ .$$

On la calcule par approximations successives : on définit les relations $\sim_k$ pour $k \in \N$ par 
$$p \sim_k q \Longleftrightarrow \forall w \in A^{\leq k},\ (p \cdot w \in L(\A) \Leftrightarrow q \cdot w \in L(\A))\ .$$
$A^{\leq k}$ est l'ensemble des mots de longueur au plus $k$.

\begin{question}
Montrer que $\sim\ =\ \sim_{n-2}$.
\end{question}

%
%Pour maintenir ces relations successives, on utilise un tableau \code{tab\_partition} d'entiers de taille $n$.
%La valeur \code{tab\_partition.(i)} est un état $j \leq i$ qui est en relation avec $i$.
%La fonction \code{classe} calcule le représentant minimal de la classe de $i$, et met à jour les valeurs
%des états considérés.
%Pour tester si deux états sont en relation, il suffit de calculer les représentants minimaux de leurs deux classes,
%et de les comparer.


\begin{question}
\'Ecrire une fonction \code{minimise} qui calcule l'automate minimal.
\end{question}

%\begin{figure}
%\begin{center}
%\begin{picture}(40,40)(0,0)
%	\gasset{Nw=8,Nh=8}
%
%  	\node[Nmarks=i](0)(0,20){$0$}
%  	\node[fangle=45,Nmarks=f](1)(20,30){$1$}
%  	\node[fangle=-45,Nmarks=f](2)(20,10){$2$}
%  	\node(3)(40,20){$3$}
%
%  	\drawedge(0,1){$a$}
%  	\drawedge(0,2){$b$}
%	\drawloop[loopangle=135](1){$a$}
%  	\drawedge(1,3){$b$}
%  	\drawedge(2,3){$b$}
%	\drawloop[loopangle=-135](2){$a$}
%	\drawloop[loopangle=0](3){$a,b$}
%\end{picture}
%\end{center}
%\end{figure}

%\begin{codesection}
%let rec classe tab i =\\
%  if tab.(i) = i \\
%  then i \\
%  else let j = classe tab tab.(i) in tab.(i) <- j ; j;;\\
%\\
%let equ tab i j =\\
%  classe tab i = classe tab j ;;\\
%\end{codesection}

\section{Question difficile}

\begin{question}
Un autre cas d'école où l'algorithme Union-Find est intéressant est le calcul des composantes connexes 
(dans un graphe non-orienté) ou des composantes fortement connexes (dans un graphe orienté).
\'Ecrire deux fonctions \code{calcul\_cc} et \code{calcul\_cfc} qui calculent les partitions correspondantes à ces deux relations
d'équivalences.
\end{question}

\begin{question}
Comment générer un labyrinthe en utilisant l'algorithme Union-Find ?
\end{question}

\end{document}
