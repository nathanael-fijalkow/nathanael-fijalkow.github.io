<p>Click <a href="?page=pub_year">here</a> for my publication list by year.


<div id="accordion" class="panel-group">
<h3>Games and synthesis</h3>

<div class="panel panel-default">

    <div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#program_synthesis" data-parent="#accordion">Program synthesis</button>
    </div>

<div id="program_synthesis" class="panel-collapse collapse">
        <div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[FMV20]</td>
                <td class="entree"><a id="FMV20"></a>Nathana&euml;l Fijalkow, Bastien Maubert, and Moshe Y. Vardi
                            <span class="titre">Assume-Guarantee Synthesis for Prompt Linear Temporal Logic</span>,
                                <span class="booktitle"><em>International Joint Conference on Artificial Intelligence, IJCAI'20</em></span>.
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFMV20">Display/Hide the abstract</button>
                                <div id="abstractFMV20" class="collapse">
                                        <i>
Prompt-LTL extends Linear Temporal Logic with a bounded version of the
eventually operator to express temporal requirements such as
bounding waiting times.  We study assume-guarantee synthesis for
prompt-LTL: the goal is to construct a system such that for all
environments satisfying a first prompt-LTL formula (the assumption)
the system composed with this environment satisfies a second
prompt-LTL formula (the guarantee).  This problem has been open for a
decade. We construct an algorithm for solving it and show that, like
classical LTL synthesis, it is 2-EXPTIME-complete.
                                        </i>
                                </div>
                        </td>
                </tr>	

                <tr>
                        <td class="labels">[CMFGP20]</td>
                <td class="entree"><a id="CMFGP20"></a>Judith Clymo, Haik Manukian, Nathana&euml;l Fijalkow, Adrià Gascón, and Brooks Paige
                            <span class="titre">Data Generation for Neural Programming by Example</span>,
                                <span class="booktitle"><em>International Conference on Artificial Intelligence and Statistics, AISTATS'20</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1911.02624">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCMFGP20">Display/Hide the abstract</button>
                                <div id="abstractCMFGP20" class="collapse">
                                        <i>
Programming by example is the problem of synthesizing a program from a small set of input / output pairs. Recent works applying machine learning methods to this task show promise, but are typically reliant on generating synthetic examples for training. A particular challenge lies in generating meaningful sets of inputs and outputs, which well-characterize a given program and accurately demonstrate its behavior. Where examples used for testing are generated by the same method as training data then the performance of a model may be partly reliant on this similarity. In this paper we introduce a novel approach using an SMT solver to synthesize inputs which cover a diverse set of behaviors for a given program. We carry out a case study comparing this method to existing synthetic data generation procedures in the literature, and find that data generated using our approach improves both the discriminatory power of example sets and the ability of trained machine learning models to generalize to unfamiliar data.
                                        </i>
                                </div>
                        </td>
                </tr>	
        </table>
        </div>
</div>

</div>


<div class="panel panel-default">

    <div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#algo_games" data-parent="#accordion">Parity games and the likes</button>
    </div>

<div id="algo_games" class="panel-collapse collapse">
        <div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[CF19]</td>
                <td class="entree"><a id="CF19"></a>Thomas Colcombet and Nathana&euml;l Fijalkow
                               <span class="titre">Universal graphs and Good for small games automata: New tools for infinite duration games</span>,
                                <span class="booktitle"><em>International Conference on Foundations of Software Science and Computation Structures, FoSSaCS'19 (invited paper)</em></span>.
                                (<a class="link" href="pdf/main-fossacs2019.pdf">Author version</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCF19">Display/Hide the abstract</button>
                                <div id="abstractCF19" class="collapse">
                                        <i>
In this paper, we give a self contained presentation of a recent breakthrough in the theory of infinite duration games: the existence of a quasipolynomial time algorithm for solving parity games. 
We introduce for this purpose two new notions: good for small games automata and universal graphs.
<br/>
The first object, good for small games automata, induces a generic algorithm for solving games by reduction to safety games. We show that it is in a strong sense equivalent to the second object, universal graphs, which is a combinatorial notion easier to reason with. Our equivalence result is very generic in that it holds for all existential memoryless winning conditions, not only for parity conditions.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[CDFJLP19]</td>
                <td class="entree"><a id="CDFJLP19"></a>Wojciech Czerwi&#324;ski, Laure Daviaud, Nathana&euml;l Fijalkow, Marcin Jurdzi&#324;ski, Ranko Lazi&#263;, and Pawe&#322; Parys
                                <span class="titre">Universal trees grow inside separating automata: Quasi-polynomial lower bounds for parity games</span>,
                                <span class="booktitle"><em>Symposium On Discrete Algorithms, SODA'2019</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1807.10546">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCDFJLP19">Display/Hide the abstract</button>
                                <div id="abstractCDFJLP19" class="collapse">
                                        <i>
Several distinct techniques have been proposed to design quasi-polynomial algorithms for solving parity games since the breakthrough result of Calude, Jain, Khoussainov, Li, and Stephan (2017): play summaries, progress measures and register games. We argue that all those techniques can be viewed as instances of the separation approach to solving parity games, a key technical component of which is constructing (explicitly or implicitly) an automaton that separates languages of words encoding plays that are (decisively) won by either of the two players. Our main technical result is a quasi-polynomial lower bound on the size of such separating automata that nearly matches the current best upper bounds. This forms a barrier that all existing approaches must overcome in the ongoing quest for a polynomial-time algorithm for solving parity games. The key and fundamental concept that we introduce and study is a universal ordered tree. The technical highlights are a quasi-polynomial lower bound on the size of universal ordered trees and a proof that every separating safety automaton has a universal tree hidden in its state space.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[CFH14]</td>
                        <td class="entree">
                                <a name="CFH14"></a>Thomas Colcombet, Nathana&euml;l Fijalkow and Florian Horn. 
                                <span class="titre">Playing Safe</span>,
                                <span class="booktitle"><em>Foundations of Software Technology and Theoretical Computer Science, FSTTCS'2014</em></span>.
                                (<a class="link" href="pdf/playing_safe.pdf">Conference version (full)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCFH14">Display/Hide the abstract</button>
                                <div id="abstractCFH14" class="collapse">
                                        <i>We consider two-player games over graphs and give tight bounds on the memory size of strategies ensuring safety conditions. 
                                        More specifically, we show that the minimal number of memory states of a strategy ensuring a safety condition is given by 
                                        the size of the maximal antichain of left quotients with respect to language inclusion. 
                                        This result holds for all safety conditions without any regularity assumptions, and for all (finite or infinite) graphs of finite degree.
                                        <br/>
                                        We give several applications of this general principle. In particular, we characterize the exact memory requirements 
                                        for the opponent in generalized reachability games,
                                        and we prove the existence of optimal positional strategies in games with counters.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FH13]</td>
                        <td class="entree"><a name="FH13-TSI"></a>Nathana&euml;l Fijalkow and Florian Horn. 
                                <span class="titre">Jeux d'accessibilit&eacute; g&eacute;n&eacute;ralis&eacute;e (in French)</span>,
                                <span class="booktitle"><em>Techniques et sciences informatiques (TSI), Num&eacute;ro sp&eacute;cial th&eacute;orie des jeux en informatique</em></span>. 
                                (<a class="link" href="pdf/jeux_accessibilite_generalisee_tsi.pdf">Journal version</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFH13">Display/Hide the abstract</button>
                                <div id="abstractFH13" class="collapse">
                                        <i>Dans cet article, nous &eacute;tudions les jeux d'accessibilit&eacute; g&eacute;n&eacute;ralis&eacute;e : 
                                        ce sont des jeux &agrave; deux joueurs &agrave; somme nulle, pour lesquels l'objectif du premier joueur, 
                                        &egrave;ve, est donn&eacute; par une conjonction d'objectifs d'accessibilit&eacute;. 
                                        Dans un premier temps, nous montrons que le probl&egrave;me de d&eacute;cider si &Egrave;ve a une strat&eacute;gie gagnante est PSPACE-complet, 
                                        mais polynomial en fixant pour param&egrave;tre le nombre d’objectifs. 
                                        De plus, nous montrons que pour les deux joueurs, les strat&eacute;gies gagnantes n&eacute;cessitent beaucoup de m&eacute;moire : 
                                        des bornes sup&eacute;rieures et inf&eacute;rieures sont pr&eacute;sent&eacute;es. 
                                        Dans un second temps, nous nous int&eacute;ressons &agrave; des restrictions de ces jeux pour lesquels nous cherchons des algorithmes efficaces 
                                        pour d&eacute;cider du gagnant et construire des strat&eacute;gies gagnantes.
                                        <br/><br/>
                                        In this paper, we consider two-player zero-sum games with generalized reachability objectives, defined as conjunctions of reachability objectives. 
                                        We first prove that deciding the winner in such games is PSPACE-complete, although it is fixed-parameter tractable with 
                                        the number of reachability objectives as parameter. Moreover, we consider the memory requirements for both players and give 
                                        matching upper and lower bounds on the size of winning strategies. 
                                        In order to construct more efficient algorithms, we consider subclasses of generalized reachability games.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[CF11b]</td>
                        <td class="entree"><a name="CF11-GanDALF"></a>Krishnendu Chatterjee and Nathana&euml;l Fijalkow. 
                                <span class="titre">A reduction from parity games to simple stochastic games</span>, In
                                <span class="booktitle"><em>Games, Automata, Logics and Formal Verification, GanDALF'2011</em></span>.
                                (<a class="link" href="pdf/reduction_gandalf.pdf">Conference version (full)</a> ; 
                                <a class="link" href="http://arxiv.org/abs/1106.1232">Technical report (ArXiv)</a>) 
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCF11b">Display/Hide the abstract</button>
                                <div id="abstractCF11b" class="collapse">
                                        <i>Games on graphs provide a natural model for reactive non-terminating systems. 
                                        In such games, the interaction of two players on an arena results in an infinite path that describes a run of the system. 
                                        Different settings are used to model various open systems in computer science, as for instance turn-based or concurrent moves, 
                                        and deterministic or stochastic transitions. 
                                        In this paper, we are interested in turn-based games, and specifically in deterministic parity games and stochastic reachability games 
                                        (also known as simple stochastic games). 
                                        We present a simple, direct and efficient reduction from deterministic parity games to simple stochastic games: 
                                        it yields an arena whose size is linear up to a logarithmic factor in size of the original arena.
                                        </i>
                                </div>
                        </td>
                </tr>	
        </table>
        </div>
</div>

</div>

<div class="panel panel-default">

<div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#games_counters" data-parent="#accordion">Games with counters</button>
</div>

<div id="games_counters" class="panel-collapse collapse">
        <div class="panel-body">
I studied the LoCo conjecture for the best of my PhD studies. It is about the existence of finite-memory winning strategies in games with counters.
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[FHKS15]</td>
                        <td class="entree">
                                <a name="FHKS15"></a>Nathana&euml;l Fijalkow, Florian Horn, Denis Kuperberg and Micha&#322; Skrzypczak. 
                                <span class="titre">Trading Bounds for Memory in Games with Counters</span>,
                                <span class="booktitle"><em>International Colloquium on Automata, Languages and Programming, ICALP'2015</em></span>.
                                (<a class="link" href="pdf/LoCo_ICALP_2015.pdf">Conference version</a> ;
                                <a class="link" href="pdf/tech_report_loco.pdf">Technical report</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFHKS15">Display/Hide the abstract</button>
                                <div id="abstractFHKS15" class="collapse">
                                        <i>We study two-player games with counters, where the objective of the first player is that the counter values remain bounded. 
                                        We investigate the existence of a trade-off between the size of the memory and the bound achieved on the counters, 
                                        which has been conjectured by Colcombet and Loeding.
                                        <br/>
                                        We show that unfortunately this conjecture does not hold: there is no trade-off between bounds and memory, even for finite arenas. 
                                        On the positive side, we prove the existence of a trade-off for the special case of thin tree arenas.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[CF13]</td>
                        <td class="entree"><a name="CF13"></a>Krishnendu Chatterjee and Nathana&euml;l Fijalkow. 
                                <span class="titre">Infinite-state games with finitary conditions</span>,
                                <span class="booktitle"><em>Computer Science Logic, CSL'2013</em></span>. 
                                (<a class="link" href="pdf/finitary_games_csl_2013.pdf">Conference version</a> ;
                                <a class="link" href="http://arxiv.org/abs/1301.2661">Technical report (ArXiv)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCF13">Display/Hide the abstract</button>
                                <div id="abstractCF13" class="collapse">
                                        <i>We study two-player zero-sum games over infinite-state graphs equipped with finitary conditions. 
                                        Such conditions refine the classical omega-regular conditions: instead of requiring that good events occur infinitely often, 
                                        they ensure the existence of a bound B such that in the limit good events occur within B steps. 
                                        <br/>
                                        Our first contribution is to give (non-effective) characterizations of the winning regions for finitary games over countably infinite-state graphs. 
                                        From these results we obtain the strategy complexity, i.e the memory required for winning strategies: 
                                        we prove that memoryless strategies are sufficient for finitary Buchi, and finite memory suffices for finitary parity. 
                                        <br/>
                                        We then study pushdown games with finitary conditions, with two contributions. 
                                        First we prove a collapse result for pushdown games with finitary conditions, implying the decidability of solving these games. 
                                        Second we consider pushdown games with finitary parity along with stack boundedness conditions, and show that solving these games is EXPTIME-complete.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[FZ14]</td>
                        <td class="entree"><a name="FZ14"></a>Nathana&euml;l Fijalkow and Martin Zimmermann. 
                                <span class="titre">Parity and Streett Games with Costs</span>,
                                <span class="booktitle"><em>Logical Methods in Computer Science, LMCS</em></span>. 
                                (<a class="link" href="http://arxiv.org/abs/1207.0663">Journal version (LMCS, on ArXiv)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFZ14">Display/Hide the abstract</button>
                                <div id="abstractFZ14" class="collapse">
                                        <i>We consider two-player games played on finite graphs equipped with costs on edges and introduce two winning conditions, cost-parity and cost-Streett, 
                                        which require bounds on the cost between requests and their responses. 
                                        Both conditions generalize the corresponding classical omega-regular conditions and the corresponding finitary conditions. 
                                        For parity games with costs we show that the first player has positional winning strategies and that determining the winner lies in NP and coNP. 
                                        For Streett games with costs we show that the first player has finite-state winning strategies and that determining the winner is EXPTIME-complete. 
                                        The second player might need infinite memory in both games. Both types of games with costs can be solved by solving linearly many instances 
                                        of their classical variants.
                                        <br/><br/>
                                        This is the journal version of [FZ12].
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[FZ12]</td>
                        <td class="entree"><a name="FZ12"></a>Nathana&euml;l Fijalkow and Martin Zimmermann. 
                                <span class="titre">Cost-parity and Cost-Streett Games</span>,
                                <span class="booktitle"><em>Foundations of Software Technology and Theoretical Computer Science, FSTTCS'2012</em></span>. 
                                (<a class="link" href="pdf/cost_parity_games_fsttcs.pdf">Conference version with appendix</a> ;
                                <a class="link" href="http://arxiv.org/abs/1207.0663">Journal version (LMCS)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFZ12">Display/Hide the abstract</button>
                                <div id="abstractFZ12" class="collapse">
                                        <i>We consider games played on graphs equipped with costs on edges, and introduce two winning conditions, cost-parity and cost-Streett, 
                                        which require bounds on the cost between requests and their responses.
                                        <br/>
                                        Both conditions generalize the corresponding classical omega-regular conditions as well as the corresponding finitary conditions.
                                        For cost-parity games we show that the first player has positional winning strategies and that determining the winner lies in NP and co-NP. 
                                        For cost-Streett games we show that the first player has finite-state winning strategies and that determining the winner is EXPTIME-complete. 
                                        This unifies the complexity results for the classical and finitary variants of these games. 
                                        Both types of cost-games can be solved by solving linearly many instances of their classical variants.
                                        </i>
                                </div>
                        </td>
                </tr>	
        </table>
        </div>
</div>

</div>




</div>








<div id="accordion" class="panel-group">
<h3>Automata and Logic</h3>

<div class="panel panel-default">

<div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#algo_pa" data-parent="#accordion">Probabilistic automata</button>
</div>

<div id="algo_pa" class="panel-collapse collapse">
        <div class="panel-body">
        <br/>
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[CF20]</td>
                        <td class="entree">
                                <a id="CF20"></a>Alexander Clark and Nathana&euml;l Fijalkow. 
                                <span class="titre">Consistent unsupervised estimators for anchored PCFGs</span>,
                                <span class="booktitle"><em>Transactions of the Association for Computational Linguistics</em></span>.
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCF20">Display/Hide the abstract</button>
                                <div id="abstractCF20" class="collapse">
                                        <i>
Learning probabilistic context-free grammars from strings is a classic problem in computational linguistics since Horning (1969). 
Here we present an algorithm based on distributional learning that is a consistent estimator for a large class of PCFGs that satisfy certain natural conditions including being anchored (Stratos et al., 2016). We proceed via a reparameterisation of (top-down) PCFGs which we call a bottom-up weighted context-free grammar. We show that if the grammar is anchored and satisfies additional restrictions on its ambiguity, then the parameters can be directly related to distributional properties of the anchoring strings; we show the asymptotic correctness of a naive estimator and present some simulations using synthetic data that show that algorithms based on this approach have good finite sample behaviour.
                                        </i>
                                </div>
                        </td>
                </tr>

                <tr>
                        <td class="labels">[CFO20]</td>
                <td class="entree"><a id="CFO20"></a>Thomas Colcombet, Nathana&euml;l Fijalkow, and Pierre Ohlmann
                            <span class="titre">Controlling a random population</span>,
                                <span class="booktitle"><em>International Conference on Foundations of Software Science and Computation Structures, FoSSaCS'20</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1911.01195">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCFO20">Display/Hide the abstract</button>
                                <div id="abstractCFO20" class="collapse">
                                        <i>
Bertrand et al. introduced a model of parameterised systems, where each agent is represented by a finite state system, and studied the following control problem: for any number of agents, does there exist a controller able to bring all agents to a target state? They showed that the problem is decidable and EXPTIME-complete in the adversarial setting, and posed as an open problem the stochastic setting, where the agent is represented by a Markov decision process. In this paper, we show that the stochastic control problem is decidable. Our solution makes significant uses of well quasi orders, of the max-flow min-cut theorem, and of the theory of regular cost functions. 
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[Fij17]</td>
                        <td class="entree">
                                <a id="Fji17"></a>Nathana&euml;l Fijalkow. 
                                <span class="titre">Undecidable problems for probabilistic automata</span>,
                                <span class="booktitle"><em>Automata column in SIGLOG news</em></span>.
                                (<a class="link" href="http://siglog.org/download/14th-newsletter-october-2017/?wpdmdl=395">Online version</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFij17-SIGLOG">Display/Hide the abstract</button>
                                <div id="abstractFij17-SIGLOG" class="collapse">
                                        <i>The model of probabilistic automata was introduced by Rabin in 1963. Ever since, undecidability results were obtained for this model, showing that although simple, it is very expressive. This paper provides streamlined constructions implying the most important negative results, including the celebrated inapproximability result of Condon and Lipton.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FRW20]</td>
                        <td class="entree">
                                <a id="FKP17"></a>Nathana&euml;l Fijalkow, Cristian Riveros and James Worrell. 
                                <span class="titre">Probabilistic Automata of Bounded Ambiguity</span>,
                                <span class="booktitle"><em>Information and Computation</em>, special issue on "Weighted Automata"</span>.
                                (<a class="link" href="https://drops.dagstuhl.de/opus/volltexte/2017/7771/">Conference version: Dagstuhl link</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFRW20">Display/Hide the abstract</button>
                                <div id="abstractFRW20" class="collapse">
                                        <i>
Probabilistic automata are an extension of nondeterministic finite automata in which transitions are annotated with probabilities. Despite its simplicity, this model is very expressive and many of the associated algorithmic questions are undecidable. In this work we focus on the emptiness problem (and its variant the value problem), which asks whether a given probabilistic automaton accepts some word with probability greater than a given threshold. We consider a natural and well-studied structural restriction on automata, namely the degree of ambiguity, which is defined as the maximum number of accepting runs over all words. The known undecidability proofs exploits infinite ambiguity and so we focus on the case of finitely ambiguous probabilistic automata.
<br/>
Our main contributions are to construct efficient algorithms for analysing finitely ambiguous probabilistic automata through a reduction to a multi-objective optimisation problem called the stochastic path problem. We obtain a polynomial time algorithm for approximating the value of probabilistic automata of fixed ambiguity and a quasi-polynomial time algorithm for the emptiness problem for 2-ambiguous probabilistic automata.
<br/>
We complement these positive results by an inapproximability result stating that the value of finitely ambiguous probabilistic automata cannot be approximated unless P = NP.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FRW17]</td>
                        <td class="entree">
                                <a name="FKP17"></a>Nathana&euml;l Fijalkow, Cristian Riveros and James Worrell. 
                                <span class="titre">Probabilistic Automata of Bounded Ambiguity</span>,
                                <span class="booktitle"><em>International Conference on Concurrency Theory, CONCUR'2017</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=7771">Conference version (full)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFRW17">Display/Hide the abstract</button>
                                <div id="abstractFRW17" class="collapse">
                                        <i>
Probabilistic automata are a computational model introduced by
Michael Rabin, extending nondeterministic finite automata with
probabilistic transitions.  Despite its simplicity, this model is
very expressive and many of the associated algorithmic questions are
undecidable.  In this work we focus on the emptiness problem, which
asks whether a given probabilistic automaton accepts some word with
probability higher than a given threshold.  We consider a natural
and well-studied structural restriction on automata, namely the
degree of ambiguity, which is defined as the maximum number of
accepting runs over all words.  We observe that undecidability of
the emptiness problem requires infinite ambiguity and so we focus on
the case of finitely ambiguous probabilistic automata.
<br/>
Our main results are to construct efficient algorithms for analysing
finitely ambiguous probabilistic automata through a reduction to a
multi-objective optimisation problem, called the stochastic path
problem.  We obtain a polynomial time algorithm for approximating
the value of finitely ambiguous probabilistic automata and a
quasi-polynomial time algorithm for the emptiness problem for
$2$-ambiguous probabilistic automata.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[Fij17]</td>
                        <td class="entree"><a name="Fij17"></a>Nathana&euml;l Fijalkow. 
                                <span class="titre">Profinite Techniques for Probabilistic Automata and the Markov Monoid Algorithm</span>,
                                <span class="booktitle"><em>Theoretical Computer Science, TCS</em></span>. 
                                (<a class="link" href="https://arxiv.org/abs/1501.02997">Technical report (ArXiv)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFij17">Display/Hide the abstract</button>
                                <div id="abstractFij17" class="collapse">
                                        <i>
We consider the value 1 problem for probabilistic automata over finite words:
it asks whether a given probabilistic automaton accepts words with probability arbitrarily close to 1.
This problem is known to be undecidable.
However, different algorithms have been proposed to partially solve it;
it has been recently shown that the Markov Monoid algorithm, based on algebra, 
is the most correct algorithm so far.
The first contribution of this paper is to give a characterisation of the Markov Monoid algorithm.
<br/>
The second contribution is to develop a profinite theory for probabilistic automata, called the prostochastic theory.
This new framework gives a topological account of the value 1 problem,
which in this context is cast as an emptiness problem.
The above characterisation is reformulated using the prostochastic theory, allowing us to give a simple and modular proof.
                                        <br/><br/>
                                        This is the journal version of [Fij16b].
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[Fij16b]</td>
                        <td class="entree">
                                <a name="F16"></a>Nathana&euml;l Fijalkow. 
                                <span class="titre">Characterisation of an Algebraic Algorithm for Probabilistic Automata</span>,
                                <span class="booktitle"><em>Symposium on Theoretical Aspects of Computer Science, STACS'2016</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=5735">Conference version</a> ; 
                                <a class="link" href="http://arxiv.org/abs/1501.02997">Technical report (ArXiv)</a>)

                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractF16b">Display/Hide the abstract</button>
                                <div id="abstractF16b" class="collapse">
                                        <i>We consider the value 1 problem for probabilistic automata over finite words:
it asks whether a given probabilistic automaton accepts words with probability arbitrarily close to 1.
This problem is known to be undecidable.
However, different algorithms have been proposed to partially solve it;
it has been recently shown that the Markov Monoid algorithm, based on algebra, 
is the most correct algorithm so far.
The first contribution of this paper is to give a characterisation of the Markov Monoid algorithm.
<br/>
The second contribution is to develop a profinite theory for probabilistic automata, called the prostochastic theory.
This new framework gives a topological account of the value 1 problem,
which in this context is cast as an emptiness problem.
The above characterisation is reformulated using the prostochastic theory, allowing to give a modular proof.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[Fij16a]</td>
                        <td class="entree">
                                <a name="F16"></a>Nathana&euml;l Fijalkow. 
                                <span class="titre">Online Space Complexity and Probabilistic Automata</span>,
                                <span class="booktitle"><em>Logical Foundations of Computer Science, LFCS'2016</em></span>.
                                (<a class="link" href="pdf/LFCS_2016.pdf">Conference version (full)</a>)

                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractF16a">Display/Hide the abstract</button>
                                <div id="abstractF16a" class="collapse">
                                        <i>In this paper, we define the online space complexity of languages,
as the size of the smallest abstract machine processing words sequentially and able to determine at every point
whether the word read so far belongs to the language or not.
The first part of this paper motivates this model and provides examples and preliminary results.
<br/>
One source of inspiration for introducing the online space complexity of languages comes from a seminal paper of Rabin from 1963, introducing probabilistic automata,
which suggests studying the online space complexity of probabilistic languages. 
This is the purpose of the second part of the current paper.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FS15]</td>
                        <td class="entree">
                                <a name="FS15"></a>Nathana&euml;l Fijalkow and Micha&#322; Skrzypczak. 
                                <span class="titre">Irregular Behaviours for Probabilistic Automata</span>,
                                <span class="booktitle"><em>Reachability Problems, RP'2015</em></span>.
                                (<a class="link" href="pdf/RP_2015.pdf">Conference version (full)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFS15">Display/Hide the abstract</button>
                                <div id="abstractFS15" class="collapse">
                                        <i>We consider probabilistic automata over finite words. Such an automaton defines the language consisting of the set of words accepted with probability greater than a given threshold. We show the existence of a universally non-regular probabilistic automaton, i.e. an automaton such that the language it defines is non-regular for every threshold. As a corollary, we obtain an alternative and very simple proof of the undecidability of determining whether such a language is regular.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FGHO14]</td>
                        <td class="entree"><a id="FP14"></a>Nathana&euml;l Fijalkow, Hugo Gimbert, Florian Horn and Youssouf Oualhadj. 
                                <span class="titre">Two Recursively Inseparable Problems for Probabilistic Automata</span>,
                                <span class="booktitle"><em>International Symposium on Mathematical Foundations of Computer Science, MFCS'2014</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1709.03122">ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFGHO14">Display/Hide the abstract</button>
                                <div id="abstractFGHO14" class="collapse">
                                        <i>This paper introduces and investigates decision problems for numberless probabilistic automata, i.e. probabilistic automata 
                                        where the support of each probabilistic transitions is specified, but the exact values of the probabilities are not.
                                        <br/>
                                        A numberless probabilistic automaton can be instantiated into a probabilistic automaton by specifying the exact values of the non-zero probabilistic transitions.
                                        <br/>We show that the two following properties of numberless probabilistic automata are recursively inseparable:
                                        <ul>
                                                <li>all instances of the numberless automaton have value 1,</li>
                                                <li>no instance of the numberless automaton has value 1.</li>
                                        </ul>
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FPS13]</td>
                        <td class="entree"><a name="FPS13"></a>Nathana&euml;l Fijalkow, Sophie Pinchinat and Olivier Serre. 
                                <span class="titre">Emptiness Of Alternating Tree Automata Using Games With Imperfect Information</span>,
                                <span class="booktitle"><em>Foundations of Software Technology and Theoretical Computer Science, FSTTCS'2013</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/volltexte/2013/4381/">Conference version (full, conference website)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFPS13">Display/Hide the abstract</button>
                                <div id="abstractFPS13" class="collapse">
                                        <i>We consider the emptiness problem for alternating parity tree automata, with two acceptance semantics: classical (all branches are accepted) and qualitative 
                                        (almost all branches are accepted). 
                                        <br/>
                                        For the classical semantics, the usual technique to tackle this problem first removes alternation, going to non-determinism, 
                                        and then checks emptiness by a reduction to a two-player perfect-information parity game. 
                                        <br/>
                                        Our first contribution is to give an alternative roadmap to this problem by directly reducing the emptiness problem to 
                                        solving an imperfect-information two-player parity game. 
                                        <br/>
                                        For the qualitative semantics, no simulation of alternation by means of non-determinism is known; yet our new approach can successfully be applied. 
                                        The key ingredient in the proof is a positionality result for stochastic games played on infinite arenas.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[FGKO15]</td>
                        <td class="entree">
                                <a id="FGKO15"></a>Nathana&euml;l Fijalkow, Hugo Gimbert, Edon Kelmendi and Youssouf Oualhadj. 
                                <span class="titre">Deciding the value 1 problem for probabilistic leaktight automata</span>,
                                <span class="booktitle"><em>Logical Methods in Computer Science, LMCS</em></span>. 
                                (<a class="link" href="http://arxiv.org/abs/1504.04136">ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFGKO15">Display/Hide the abstract</button>
                                <div id="abstractFGKO15" class="collapse">
                                        <i>The value 1 problem is a decision problem for probabilistic automata over finite words:
                                        given a probabilistic automaton, are there words accepted with probability arbitrarily close to 1?
                                        This problem was proved undecidable recently; to overcome this, several classes of probabilistic automata of different nature were proposed, 
                                        for which the value 1 problem has been shown decidable.
                                        In this paper, we introduce yet another class of probabilistic automata, called \textit{leaktight automata}, 
                                        which strictly subsumes all classes of probabilistic automata whose value 1 problem is known to be decidable.
                                        <br/>
                                        We prove that for leaktight automata, the value 1 problem is decidable (in fact, PSPACE-complete) by constructing 
                                        a saturation algorithm based on the computation of a monoid abstracting the behaviours of the automaton.
                                        We rely on algebraic techniques developed by Simon to prove that this abstraction is complete.
                                        Furthermore, we adapt this saturation algorithm to decide whether an automaton is leaktight.
                                        <br/>
                                        Finally, we show a reduction allowing to extend our decidability results from finite words to infinite ones, 
                                        implying that the value 1 problem for probabilistic leaktight parity automata is decidable.
                                        <br/><br/>
                                        This is the journal version of [FGO12].
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[FGO12]</td>
                        <td class="entree"><a id="FGO12-LICS"></a>Nathana&euml;l Fijalkow, Hugo Gimbert and Youssouf Oualhadj.
                                <span class="titre">Deciding the Value 1 Problem for Probabilistic Leaktight Automata</span>,
                                <span class="booktitle"><em>Logic in Computer Science, LICS'2012</em></span>.
                                (<a class="link" href="http://arxiv.org/abs/1504.04136">ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFGO12">Display/Hide the abstract</button>
                                <div id="abstractFGO12" class="collapse">
                                        <i>The value 1 problem is a decision problem for probabilistic automata over finite words: 
                                        given a probabilistic automaton, are there words accepted with probability arbitrarily close to 1? 
                                        This problem was proved undecidable recently. 
                                        We sharpen this result, showing that the undecidability result holds even if the probabilistic automata have only one probabilistic transition. 
                                        Our main contribution is to introduce a new class of probabilistic automata, called leaktight automata, for which the value 1 problem is shown decidable 
                                        (and PSPACE-complete). 
                                        We construct an algorithm based on the computation of a monoid abstracting the behaviours of the automaton, 
                                        and rely on algebraic techniques developed by Simon for the correctness proof. 
                                        The class of leaktight automata is decidable in PSPACE, subsumes all subclasses of probabilistic automata whose value 1 problem is known to be decidable 
                                        (in particular deterministic automata), and is closed under two natural composition operators.
                                        </i>
                                </div>
                        </td>
                </tr>	
        </table>
        </div>
</div>

</div>








<div class="panel panel-default">

    <div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#automata_counters" data-parent="#accordion">Automata with counters</button>
    </div>

<div id="automata_counters" class="panel-collapse collapse">
<div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[FMMR18]</td>
                <td class="entree"><a id="FMMR18"></a>Nathana&euml;l Fijalkow, Bastien Maubert, Aniello Murano, and Sasha Rubin
                                <span class="titre">Quantifying bounds in Strategy Logic</span>,
                                <span class="booktitle"><em>Computer Science Logic, CSL'2018</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/volltexte/2018/9690/">Conference version: Dagstuhl link</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFMMR18">Display/Hide the abstract</button>
                                <div id="abstractFMMR18" class="collapse">
                                        <i>
Program synthesis constructs programs from specifications in an automated way. 
Strategy Logic (SL) is a powerful and versatile specification language whose goal is to give theoretical foundations for program synthesis in a multi-agent setting. 
One limitation of Strategy Logic is that it is purely qualitative. 
For instance it cannot specify quantitative properties of executions such as ''every request is quickly granted'', 
or quantitative properties of trees such as ''most executions of the system terminate''. 
<br/>
In this work, we extend Strategy Logic to include quantitative aspects in a way that can express bounds on ''how quickly'' and ''how many''. 
We define Prompt Strategy Logic, which encompasses Prompt LTL (itself an extension of LTL with a prompt eventuality temporal operator), 
and we define Bounded-Outcome Strategy Logic which has a bounded quantifier on paths. 
We supply a general technique, based on the study of automata with counters, that solves the model-checking problems for both these logics.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[CF16]</td>
                        <td class="entree">
                                <a name="CF16"></a>Thomas Colcombet and Nathana&euml;l Fijalkow. 
                                <span class="titre">The Bridge between Omega-Regular Languages and the Theory of Regular Cost Functions</span>,
                                <span class="booktitle"><em>International Colloquium on Automata, Languages and Programming, ICALP'2016</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=6261">Conference version (full)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCF16">Display/Hide the abstract</button>
                                <div id="abstractCF16" class="collapse">
                                        <i>In this paper, we exhibit a one-to-one correspondence between omega-regular languages and a subclass of regular cost functions over finite words, called omega-regular like cost functions. This bridge between the two models allows one to readily import classical results such as the last appearance record or the McNaughton-Safra constructions to the realm of regular cost functions. In combination with game theoretic techniques, this also yields a simple description of an optimal procedure of history-determinisation for cost automata, a central result in the theory of regular cost functions.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[CF11a]</td>
                        <td class="entree"><a name="CF11-LATA"></a>Krishnendu Chatterjee and Nathana&euml;l Fijalkow. 
                                <span class="titre">Finitary languages</span>, In
                                <span class="booktitle"><em>Language and Automata Theory and Applications, LATA'2011</em></span>.
                                (<a class="link" href="pdf/finitary_lata.pdf">Conference version</a> ; 
                                <a class="link" href="http://arxiv.org/abs/1101.1727">Technical report (ArXiv)</a>) 
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCF11a">Display/Hide the abstract</button>
                                <div id="abstractCF11a" class="collapse">
                                        <i>The class of omega-regular languages provides a robust specification language in verification. 
                                        Every omega-regular condition can be decomposed into a safety part and a liveness part. 
                                        The liveness part ensures that something good happens "eventually". 
                                        Finitary liveness was proposed by Alur and Henzinger as a stronger formulation of liveness. 
                                        It requires that there exists an unknown, fixed bound b such that something good happens within b transitions. 
                                        In this work we consider automata with finitary acceptance conditions defined by finitary Buchi, parity and Streett languages. 
                                        We study languages expressible by such automata: we give their topological complexity and present a regular-expression characterization. 
                                        We compare the expressive power of finitary automata and give optimal algorithms for classical decisions questions. 
                                        We show that the finitary languages are Sigma 2-complete; we present a complete picture of the expressive power of various classes of automata with finitary 
                                        and infinitary acceptance conditions; 
                                        we show that the languages defined by finitary parity automata exactly characterize the star-free fragment of omega B-regular languages; 
                                        and we show that emptiness is NLOGSPACE-complete and universality as well as language inclusion are PSPACE-complete for finitary parity and Streett automata.
                                        </i>
                                </div>
                        </td>
                </tr>	
        </table>
        </div>
</div>

</div>

<div class="panel panel-default">
<div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#tool" data-parent="#accordion">Tool developments</button>
</div>

<div id="tool" class="panel-collapse collapse">
        <div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[FGKK17]</td>
                        <td class="entree">
                                <a name="FGKK17"></a>Nathana&euml;l Fijalkow, Hugo Gimbert, Edon Kelmendi and Denis Kuperberg. 
                                <span class="titre">Stamina: Stabilisation Monoids in Automata Theory</span>,
                                <span class="booktitle"><em>Conference on Implementation of Automata and Applications, CIAA'2017</em></span>.
                                (<a class="link" href="pdf/stamina.pdf">Conference version (full)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFGKK17tool">Display/Hide the abstract</button>
                                <div id="abstractFGKK17tool" class="collapse">
                                        <i>We present Stamina, a tool solving three algorithmic problems in automata theory.
First, compute the star height of a regular language, i.e. the minimal number of nested Kleene stars needed for expressing the language 
with a complement-free regular expression.
Second, decide limitedness for regular cost functions.
Third, decide whether a probabilistic leaktight automaton has value 1, i.e. whether a probabilistic leaktight automaton 
accepts words with probability arbitrarily close to 1.
<br/>
All three problems reduce to the computation of the stabilisation monoid associated with an automaton, 
which is computationally challenging because the monoid is exponentially larger than the automaton.
The compact data structures used in Stamina, together with optimisations and heuristics, allow us to handle automata with several hundreds of states.
This radically improves upon the performances of ACME, a similar tool solving a subset of these problems.
<br/>
The tool Stamina is open source and available from Github, details are given on the <a href="http://stamina.labri.fr">dedicated webpage</a>.
                                        </i>
                                </div>
                        </td>
                </tr>

                <tr>
                        <td class="labels">[FK14]</td>
                        <td class="entree">
                                <a name="FP14"></a>Nathana&euml;l Fijalkow and Denis Kuperberg. 
                                <span class="titre">ACME: Automata with Counters, Monoids and Equivalence</span>,
                                <span class="booktitle"><em>International Symposium on Automated Technology for Verification and Analysis, ATVA'2014</em></span>.
                                (<a class="link" href="?page=acme">Dedicated webpage</a> ; <a class="link" href="pdf/acme.pdf">Conference version</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFK14tool">Display/Hide the abstract</button>
                                <div id="abstractFK14tool" class="collapse">
                                        <i>We present ACME, a tool implementing algebraic techniques to solve decision problems from automata theory.
                                        The core generic algorithm takes as input an automaton and computes its stabilization monoid,
                                        which is a generalization of its transition monoid.
                                        <br/>
                                        Using the stabilization monoid, one can solve many problems:
                                        determine whether a B-automaton (which is a special kind of automata with counters) is limited, whether two B-automata are equivalent
                                        and whether a probabilistic leaktight automaton has value 1.
                                        </i>
                                </div>
                        </td>
                </tr>
        </table>
        </div>
</div>

</div>




<div class="panel panel-default">
<div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#others" data-parent="#accordion">Others</button>
</div>

<div id="others" class="panel-collapse collapse">
        <div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[FLOS20]</td>
                <td class="entree"><a id="FLOS20"></a>Nathana&euml;l Fijalkow, Guillaume Lagarde, Pierre Ohlmann, and Olivier Serre
                            <span class="titre">Lower bounds for arithmetic circuits via the Hankel matrix</span>,
                                <span class="booktitle"><em>Symposium on Theoretical Aspects of Computer Science, STACS'2020</em></span>.
                                (<a class="link" href="https://drops.dagstuhl.de/opus/frontdoor.php?source_opus=11885">Conference version: Dagstuhl link</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFLOS20">Display/Hide the abstract</button>
                                <div id="abstractFLOS20" class="collapse">
                                        <i>
We study the complexity of representing polynomials by arithmetic circuits in both the commutative and the non-commutative settings. Our approach goes through a precise understanding of the more restricted setting where multiplication is not associative, meaning that we distinguish (xy)z from x(yz).
<br/>
Our first and main conceptual result is a characterization result: we show that the size of the smallest circuit computing a given non-associative polynomial is exactly the rank of a matrix constructed from the polynomial and called the Hankel matrix. This result applies to the class of all circuits in both commutative and non-commutative settings, and can be seen as an extension of the seminal result of Nisan giving a similar characterization for non-commutative algebraic branching programs.
<br/>
The study of the Hankel matrix provides a unifying approach for proving lower bounds for polynomials in the (classical) associative setting. We demonstrate this by giving alternative proofs of recent results proving superpolynomial and exponential lower bounds for different classes of circuits as corollaries of our characterization result.
<br/>
Our main technical contribution is to provide generic lower bound theorems based on analyzing and decomposing the Hankel matrix. This yields significant improvements on lower bounds for circuits with many parse trees, in both (associative) commutative and non-commutative settings. In particular in the non-commutative setting we obtain a tight result showing superpolynomial lower bounds for any class of circuits which has a small defect in the exponent of the total number of parse trees.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[Fij20]</td>
                        <td class="entree"><a id="Fij20"></a>Nathana&euml;l Fijalkow.
                                <span class="titre">Lower bounds for the state complexity of probabilistic languages and the language of prime numbers</span>,
                                <span class="booktitle"><em>Journal of Logic and Computation (Special Issue on LFCS'2016, Logical Foundations of Computer Science)</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1912.11396">Arxiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFij20">Display/Hide the abstract</button>
                                <div id="abstractFij20" class="collapse">
                                        <i>
This paper studies the complexity of languages of finite words using automata theory.
To go beyond the class of regular languages, we consider infinite automata and the notion of state complexity defined by Karp.
<br/>
Motivated by the seminal paper of Rabin from 1963 introducing probabilistic automata, we study the (deterministic) state complexity of probabilistic languages and prove that probabilistic languages can have arbitrarily high deterministic state complexity.
<br/>
We then look at alternating automata as introduced by Chandra, Kozen and Stockmeyer:
such machines run independent computations on the word and gather their answers through boolean combinations.
We devise a lower bound technique relying on boundedly generated lattices of languages, and give two applications of this technique.
The first is a hierarchy theorem, stating that there are languages of arbitrarily high polynomial alternating state complexity,
and the second is a linear lower bound on the alternating state complexity of the prime numbers written in binary.
This second result strengthens a result of Hartmanis and Shank from 1968, which implies an exponentially worse lower bound for the same model.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[Fij18]</td>
                        <td class="entree"><a id="Fij18-LICS"></a>Nathana&euml;l Fijalkow.
                                <span class="titre">The State Complexity of Alternating Automata</span>,
                                <span class="booktitle"><em>Logic in Computer Science, LICS'2018</em></span>.
                                (<a class="link" href="https://nathanael-fijalkow.github.io/pdf/alternating_state_complexity.pdf">PDF</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFij18">Display/Hide the abstract</button>
                                <div id="abstractFij18" class="collapse">
                                        <i>This paper studies the complexity of languages of finite words using automata theory. To go beyond the class of regular languages, we consider infinite automata and the notion of state complexity defined by Karp. We look at alternating automata as introduced by Chandra, Kozen and Stockmeyer: such machines run independent computations on the word and gather their answers through boolean combinations.
<br/>
We devise a lower bound technique relying on boundedly generated lattices of languages, and give two applications of this technique. The first is a hierarchy theorem, stating that there are languages of arbitrarily high polynomial alternating state complexity, and the second is a linear lower bound on the alternating state complexity of the prime numbers written in binary. This second result strengthens a result of Hartmanis and Shank from 1968, which implies an exponentially worse lower bound for the same model.
                                        </i>
                                </div>
                        </td>
                </tr>	
                <tr>
                        <td class="labels">[FP17]</td>
                        <td class="entree"><a name="FP17"></a>Nathana&euml;l Fijalkow and Charles Paperman. 
                                <span class="titre">Monadic Second-Order Logic with Arbitrary Monadic Predicates</span>,
                                <span class="booktitle"><em>Transactions on Computational Logic, ToCL</em></span>.
                                (<a class="link" href="pdf/msounary.pdf">Journal version</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFP17">Display/Hide the abstract</button>
                                <div id="abstractFP17" class="collapse">
                                        <i>We study Monadic Second-Order Logic (MSO) over finite words, extended with (non-uniform arbitrary) monadic predicates. 
                                        We show that it defines a class of languages that has algebraic, automata-theoretic and machine-independent characterizations. 
                                        We consider the regularity question: given a language in this class, when is it regular? 
                                        To answer this, we show a substitution property and the existence of a syntactical predicate.
                                        <br/>
                                        We give three applications. The first two are to give simple proofs of the Straubing and Crane Beach Conjectures for monadic predicates, 
                                        and the third is to show that it is decidable whether a language defined by an MSO formula with morphic predicates is regular.
                                        <br/><br/>
                                        This is the journal version of [FP14].
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FP14]</td>
                        <td class="entree"><a name="FP14"></a>Nathana&euml;l Fijalkow and Charles Paperman. 
                                <span class="titre">Monadic Second-Order Logic with Arbitrary Monadic Predicates</span>,
                                <span class="booktitle"><em>International Symposium on Mathematical Foundations of Computer Science, MFCS'2014</em></span>.
                                (<a class="link" href="pdf/monadic_predicate_MFCS_2014.pdf">Conference version</a> ; 
                                <a class="link" href="pdf/tech_report_monadic_predicate.pdf">Technical report</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFP14">Display/Hide the abstract</button>
                                <div id="abstractFP14" class="collapse">
                                        <i>We study Monadic Second-Order Logic (MSO) over finite words, extended with (non-uniform arbitrary) monadic predicates. 
                                        We show that it defines a class of languages that has algebraic, automata-theoretic and machine-independent characterizations. 
                                        We consider the regularity question: given a language in this class, when is it regular? 
                                        To answer this, we show a substitution property and the existence of a syntactical predicate.
                                        <br/>
                                        We give three applications. The first two are to give simple proofs of the Straubing and Crane Beach Conjectures for monadic predicates, 
                                        and the third is to show that it is decidable whether a language defined by an MSO formula with morphic predicates is regular.
                                        </i>
                                </div>
                        </td>
                </tr>
        </table>
        </div>
</div>

</div>



</div>











<div id="accordion" class="panel-group">
<h3>Dynamical systems</h3>


<div class="panel panel-default">

<div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#process_algebra" data-parent="#accordion">Process algebra</button>
</div>

<div id="process_algebra" class="panel-collapse collapse">
        <div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[PFBLM18]</td>
                        <td class="entree">
                                <a id="FKP17"></a>Mathias Ruggaard Pedersen, Nathana&euml;l Fijalkow,  Giorgio Bacci, Kim Guldstrand Larsen, and Radu Mardare. 
                                <span class="titre">Timed Comparisons of Semi-Markov Processes</span>,
                                <span class="booktitle"><em>International Conference on Language and Automata Theory and Applications, LATA'2018</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1711.10216">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractPFBLM18">Display/Hide the abstract</button>
                                <div id="abstractPFBLM18" class="collapse">
                                        <i>
Semi-Markov processes are Markovian processes in which the firing time of the transitions is modelled by probabilistic distributions over positive reals interpreted as the probability of firing a transition at a certain moment in time. In this paper we consider the trace-based semantics of semi-Markov processes, and investigate the question of how to compare two semi-Markov processes with respect to their time-dependent behaviour. To this end, we introduce the relation of being "faster than" between processes and study its algorithmic complexity. Through a connection to probabilistic automata we obtain hardness results showing in particular that this relation is undecidable. However, we present an additive approximation algorithm for a time-bounded variant of the faster-than problem over semi-Markov processes with slow residence-time functions, and a coNP algorithm for the exact faster-than problem over unambiguous semi-Markov processes.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[CFKP19]</td>
                        <td class="entree">
                                <a id="CFKP19"></a>Florence Clerc, Nathana&euml;l Fijalkow, Bartek Klin and Prakash Panangaden. 
                                <span class="titre">Expressiveness of probabilistic modal logics: a gradual approach</span>,
                                <span class="booktitle"><em>Information and Computation</em></span>.
                                (<a class="link" href="pdf/IC_2019_bisimulation.pdf">Journal version: author link</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractCFKP19">Display/Hide the abstract</button>
                                <div id="abstractCFKP19" class="collapse">
                                        <i>
Labelled Markov processes are probabilistic versions of labelled transition systems. In general,
the state space of a labelled Markov process may be a continuum. Logical characterizations of
probabilistic bisimulation and simulation were given by Desharnais et al. These results hold for
systems defined on analytic state spaces and assume that there are countably many labels in the
case of bisimulation and finitely many labels in the case of simulation.
<br/>
In this paper, we first revisit these results by giving simpler and more streamlined proofs. In
particular, our proof for simulation has the same structure as the one for bisimulation, relying on
a new result of a topological nature. This departs from the known proof for this result, which uses
domain theoretic techniques and falls out of a theory of approximation of labelled Markov processes.
We also propose a new notion of event simulation.
<br/>
Our proofs assume the presence of countably many labels. We investigate the necessity of
this assumption, and show that the logical characterization of bisimulation may fail when there
are uncountably many labels. However, with a stronger assumption on the transition functions
(continuity instead of just measurability), we can regain the logical characterization result, for
arbitrarily many labels. These new results arose from a new game-theoretic way of understanding
probabilistic simulation and bisimulation.
                                        </i>
                                </div>
                        </td>
                </tr>
                <tr>
                        <td class="labels">[FKP17]</td>
                        <td class="entree">
                                <a id="FKP17"></a>Nathana&euml;l Fijalkow, Bartek Klin and Prakash Panangaden. 
                                <span class="titre">Expressiveness of Probabilistic Modal Logics, Revisited</span>,
                                <span class="booktitle"><em>International Colloquium on Automata, Languages and Programming, ICALP'2017</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=7368">Conference version: Dagstuhl link</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFKP17">Display/Hide the abstract</button>
                                <div id="abstractFKP17" class="collapse">
                                        <i>
Labelled Markov processes are probabilistic versions of labelled
transition systems.  In general, the state space of a labelled Markov
process may be a continuum.  Logical characterizations of probabilistic
bisimulation and simulation were given by Desharnais et al.  These
results hold for systems defined on analytic state spaces and
assume that there are countably many labels in the case of bisimulation
and finitely many labels in the case of simulation.
<br/>
In this paper, we first revisit these results by giving simpler and more
streamlined proofs.  In particular, our proof for simulation has the same
structure as the one for bisimulation, relying on a new result of a
topological nature.  This departs from the known proof
for this result, which uses domain theory techniques and falls out of a
theory of approximation of Labelled Markov processes.
<br/>
Both our proofs assume the presence of countably many labels.  We
investigate the necessity of this assumption, and show that the
logical characterization of bisimulation may fail when there are
uncountably many labels.  However, with a stronger assumption on the
transition functions (continuity instead of just measurability), we can
regain the logical characterization result, for arbitrarily many labels.
These new results arose from a new game-theoretic way of understanding
probabilistic simulation and bisimulation.
                                        </i>
                                </div>
                        </td>
                </tr>

                <tr>
                        <td class="labels">[FKS19]</td>
                        <td class="entree">
                                <a id="FKS19"></a>Nathana&euml;l Fijalkow, Stefan Kiefer and Mahsa Shirmohammadi. 
                                <span class="titre">Trace Refinement in Labelled Markov Decision Processes</span>,
                                <span class="booktitle"><em>Logical Methods in Computer Science, LMCS</em></span>.
                                (<a class="link" href="http://arxiv.org/abs/1510.09102">ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFKS19">Display/Hide the abstract</button>
                                <div id="abstractFKS19" class="collapse">
                                        <i>Given two labelled Markov decision processes (MDPs), the trace-refinement problem asks whether for all strategies of the first MDP there exists a strategy of the second MDP such that the induced labelled Markov chains are trace-equivalent. We show that this problem is decidable in polynomial time if the second MDP is a Markov chain. The algorithm is based on new results on a particular notion of bisimulation between distributions over the states. However, we show that the general trace-refinement problem is undecidable, even if the first MDP is a Markov chain. Decidability of those problems has been open since 2008. We further study the decidability and complexity of the trace-refinement problem provided that the strategies are restricted to be memoryless.
                                        </i>
                                </div>
                        </td>
                </tr>

                <tr>
                        <td class="labels">[FKS16]</td>
                        <td class="entree">
                                <a id="FKS16"></a>Nathana&euml;l Fijalkow, Stefan Kiefer and Mahsa Shirmohammadi. 
                                <span class="titre">Trace Refinement in Labelled Markov Decision Processes</span>,
                                <span class="booktitle"><em>Foundations of Software Science and Computation Structures, FoSSaCS'2016</em></span>.
                                (<a class="link" href="http://arxiv.org/abs/1510.09102">ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFKS16">Display/Hide the abstract</button>
                                <div id="abstractFKS16" class="collapse">
                                        <i>Given two labelled Markov decision processes (MDPs), the trace-refinement problem asks whether for all strategies of the first MDP there exists a strategy of the second MDP such that the induced labelled Markov chains are trace-equivalent. We show that this problem is decidable in polynomial time if the second MDP is a Markov chain. The algorithm is based on new results on a particular notion of bisimulation between distributions over the states. However, we show that the general trace-refinement problem is undecidable, even if the first MDP is a Markov chain. Decidability of those problems has been open since 2008. We further study the decidability and complexity of the trace-refinement problem provided that the strategies are restricted to be memoryless.
                                        </i>
                                </div>
                        </td>
                </tr>
        </table>
        </div>
</div>

</div>





<div class="panel panel-default">

<div class="panel-heading">
        <button type="button" class="btn btn-default btn-lg" data-toggle="collapse" data-target="#dynamical" data-parent="#accordion">Dynamical systems</button>
</div>

<div id="dynamical" class="panel-collapse collapse">
        <div class="panel-body">
        <table border="0" cellpadding="2" width="100%">
                <tr>
                        <td class="labels">[BFLM20]</td>
                <td class="entree"><a id="BFLM20"></a>Corentin Barloy, Nathana&euml;l Fijalkow, Nathan Lhote, and Filip Mazowiecki
                            <span class="titre">A Robust Class of Linear Recurrence Sequences</span>,
                                <span class="booktitle"><em>Computer Science Logic, CSL'20</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1908.03890">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractBFLM20">Display/Hide the abstract</button>
                                <div id="abstractBFLM20" class="collapse">
                                        <i>
We introduce a subclass of linear recurrence sequences which we call poly-rational sequences because they are denoted by rational expressions closed under sum and product. We show that this class is robust by giving several characterisations: polynomially ambiguous weighted automata, copyless cost-register automata, rational formal series, and linear recurrence sequences whose eigenvalues are roots of rational numbers.
                                        </i>
                                </div>
                        </td>
                </tr>	

                <tr>
                        <td class="labels">[FLOOPW19]</td>
                <td class="entree"><a id="FLOOPW19"></a>Nathana&euml;l Fijalkow, Engel Lefaucheux, Pierre Ohlmann, Jo&euml;l Ouaknine, Amaury Pouly, and James Worrell
                            <span class="titre">On the Monniaux Problem in Abstract Interpretation</span>,
                                <span class="booktitle"><em>Static Analysis Symposium, SAS'19</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1907.08257">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFLOOPW19">Display/Hide the abstract</button>
                                <div id="abstractFLOOPW19" class="collapse">
                                        <i>
The Monniaux Problem in abstract interpretation asks, roughly speaking, whether the following question is decidable: given a program P, a safety (e.g., non-reachability) specification phi, and an abstract domain of invariants D, does there exist an inductive invariant I in D guaranteeing that program P meets its specification phi. The Monniaux Problem is of course parameterised by the classes of programs and invariant domains that one considers. In this paper, we show that the Monniaux Problem is undecidable for unguarded affine programs and semilinear invariants (unions of polyhedra). Moreover, we show that decidability is recovered in the important special case of simple linear loops.
                                        </i>
                                </div>
                        </td>
                </tr>	

                <tr>
                        <td class="labels">[FOPSW19]</td>
                <td class="entree"><a id="FOPSW19"></a>Nathana&euml;l Fijalkow, Jo&euml;l Ouaknine, Amaury Pouly, Jo&atilde;o Sousa-Pinto, and James Worrell
                            <span class="titre">On the Decidability of Reachability in Linear Time-Invariant Systems</span>,
                                <span class="booktitle"><em>International Conference on Hybrid Systems: Computation and Control, HSCC'19</em></span>.
                                (<a class="link" href="https://arxiv.org/abs/1802.06575">Technical report: ArXiv</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFOPSW19">Display/Hide the abstract</button>
                                <div id="abstractFOPSW19" class="collapse">
                                        <i>
We consider the decidability of state-to-state reachability in linear time-invariant control systems, with control sets defined by boolean combinations of linear inequalities. Decidability of the sub-problem in which control sets are linear subspaces is a fundamental result in control theory. We first show that reachability is undecidable if the set of controls is a finite union of affine subspaces. We then consider two simple subclasses of control sets---unions of two affine subspaces and bounded convex polytopes respectively---and show that in these two cases the reachability problem for LTI systems is as hard as certain longstanding open decision problems concerning linear recurrence sequences. Finally we present some spectral assumptions on the transition matrix of an LTI system under which reachability becomes decidable with bounded convex polytopes as control sets. 
                                        </i>
                                </div>
                        </td>
                </tr>	

                <tr>
                        <td class="labels">[FOOPW19]</td>
                        <td class="entree">
                                <a id="FOOPW19"></a>Nathana&euml;l Fijalkow, Pierre Ohlmann, Jo&euml;l Ouaknine, Amaury Pouly and James Worrell. 
                                <span class="titre">Complete Semialgebraic Invariant Synthesis for the Kannan-Lipton Orbit Problem</span>,
                                <span class="booktitle"><em>Theory of Computing Systems (ToCS)</em></span>, special issue by invitation of STACS'2017.
                                (<a class="link" href="https://link.springer.com/article/10.1007/s00224-019-09913-3">Official link</a> ; 
				<a class="link" href="pdf/ToCS_SemiAlgebraicInvariants.pdf">Author version</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFOOPW19">Display/Hide the abstract</button>
                                <div id="abstractFOOPW19" class="collapse">
                                        <i>The Orbit Problem consists of determining, given a linear transformation A on Q^d, together with vectors x and y, whether the orbit of x under repeated applications of A can ever reach y. This problem was famously shown to be decidable by Kannan and Lipton in the 1980s.
<br/>
In this paper, we are concerned with the problem of synthesising suitable invariants P included in R^d, i.e., sets that are stable under A and contain x and not y, thereby providing compact and versatile certificates of non-reachability. 
We show that whether a given instance of the Orbit Problem admits a semialgebraic invariant is decidable, and moreover in positive instances we provide an algorithm to synthesise suitable invariants of polynomial size.
<br/>
Our results imply that the class of closed semialgebraic invariants is closure-complete: there exists a closed semialgebraic invariant if and only if y is not in the topological closure of the orbit of x under A.
                                        </i>
                                </div>
                        </td>
                </tr>

                <tr>
                        <td class="labels">[FOOPW17]</td>
                        <td class="entree">
                                <a name="FOOPW17"></a>Nathana&euml;l Fijalkow, Pierre Ohlmann, Jo&euml;l Ouaknine, Amaury Pouly and James Worrell. 
                                <span class="titre">Semialgebraic Invariant Synthesis for the Kannan-Lipton Orbit Problem</span>,
                                <span class="booktitle"><em>Symposium on Theoretical Aspects of Computer Science, STACS'2017</em></span>.
                                (<a class="link" href="http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=7005">Conference version (full)</a>)
                                <br/>
                                <button type="button" class="btn btn-primary btn-xs" data-toggle="collapse" data-target="#abstractFOOPW17">Display/Hide the abstract</button>
                                <div id="abstractFOOPW17" class="collapse">
                                        <i>The Orbit Problem consists of determining, given a linear transformation A on Q^d, together with vectors x and y, whether the orbit of x under repeated applications of A can ever reach y. This problem was famously shown to be decidable by Kannan and Lipton in the 1980s.

In this paper, we are concerned with the problem of synthesising suitable invariants P included in R^d, i.e., sets that are stable under A and contain x and not y, thereby providing compact and versatile certificates of non-reachability. 
We show that whether a given instance of the Orbit Problem admits a semialgebraic invariant is decidable, and moreover in positive instances we provide an algorithm to synthesise suitable invariants of polynomial size.

It is worth noting that the existence of semilinear invariants, on the other hand, is (to the best of our knowledge) not known to be decidable.
                                        </i>
                                </div>
                        </td>
                </tr>
        </table>
        </div>
</div>

</div>

</div>
